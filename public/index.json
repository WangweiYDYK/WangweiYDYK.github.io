[{"categories":null,"content":"Lighting ","date":"2025-02-22","objectID":"/lighting/:0:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"Phong $$L = L_{a} + L_{d} + L_{s}$$ ","date":"2025-02-22","objectID":"/lighting/:1:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"环境光（Ambient） 环境光也称间接光，是光线经过周围环境表面多次反射后形成的，利用它可以描述一块区域的亮度，在光照模型中，通常用一个常量来表示。 ","date":"2025-02-22","objectID":"/lighting/:1:1","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"漫反射（Diffuse） 兰伯特余弦定律(Lambert Consine Law)中指出漫反射的大小取决于表面法线和光线的夹角，当夹角越大时，漫反射分量越小，当夹角接近90度时，我们认为漫反射几乎为零。 $$L_d = k_d(I/r^2)max(0, n \\cdot L)$$ ","date":"2025-02-22","objectID":"/lighting/:1:2","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"高光反射（Specular） Phong模型认为高光反射的强度与反射光线R和观察角度v之间夹角的余弦值成正比 $$L_s = k_s(I/r^2)max(0, v \\cdot R)^n$$ #version 330 core out vec4 FragColor; in vec3 Normal; in vec3 FragPos; uniform vec3 lightPos; uniform vec3 viewPos; uniform vec3 lightColor; uniform vec3 objectColor; void main() { // ambient float ambientStrength = 0.1; vec3 ambient = ambientStrength * lightColor; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = diff * lightColor; // specular float specularStrength = 0.5; vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32); vec3 specular = specularStrength * spec * lightColor; vec3 result = (ambient + diffuse + specular) * objectColor; FragColor = vec4(result, 1.0); } ","date":"2025-02-22","objectID":"/lighting/:1:3","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"Blinn-Phong ","date":"2025-02-22","objectID":"/lighting/:2:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"PBR ","date":"2025-02-22","objectID":"/lighting/:3:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"辐射度量学 渲染方程$$L_o(p,\\omega_o) = \\int\\limits_{\\Omega} f_r(p,\\omega_i,\\omega_o) L_i(p,\\omega_i) n \\cdot \\omega_i d\\omega_i$$ Cook-Torrance BRDF $$f_r = k_df_{lambert} + k_sf_{cook-torrance}$$ $$f_{lambert} = \\frac{c}{\\pi}$$ $$f_{cook-torrance} = \\frac{DFG}{4(\\omega_0 \\cdot n)(\\omega_i \\cdot n)}$$ 粗略可以这么理解 $D$：法线分布函数（对应镜面的高光部分） $F$：菲涅尔方程（菲涅尔方程描述的是在不同的表面角下表面所反射的光线所占的比率， 体现了光在物体粗糙面上反射时的损耗） $G$：几何函数（返回未被遮蔽的表面的百分比，代表几何遮蔽部分） $\\omega_i$：入射光线 $\\omega_o$：视线 为什么要除以$\\pi$ ","date":"2025-02-22","objectID":"/lighting/:4:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"法线分布函数 ","date":"2025-02-22","objectID":"/lighting/:4:1","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"菲涅尔方程 ","date":"2025-02-22","objectID":"/lighting/:4:2","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"几何函数 #version 330 core out vec4 FragColor; in vec2 TexCoords; in vec3 WorldPos; in vec3 Normal; // material parameters uniform vec3 albedo; uniform float metallic; uniform float roughness; uniform float ao; // lights uniform vec3 lightPositions[4]; uniform vec3 lightColors[4]; uniform vec3 camPos; const float PI = 3.14159265359; // ---------------------------------------------------------------------------- float DistributionGGX(vec3 N, vec3 H, float roughness) { float a = roughness*roughness; float a2 = a*a; float NdotH = max(dot(N, H), 0.0); float NdotH2 = NdotH*NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = PI * denom * denom; return nom / denom; } // ---------------------------------------------------------------------------- float GeometrySchlickGGX(float NdotV, float roughness) { float r = (roughness + 1.0); float k = (r*r) / 8.0; float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } // ---------------------------------------------------------------------------- float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) { float NdotV = max(dot(N, V), 0.0); float NdotL = max(dot(N, L), 0.0); float ggx2 = GeometrySchlickGGX(NdotV, roughness); float ggx1 = GeometrySchlickGGX(NdotL, roughness); return ggx1 * ggx2; } // ---------------------------------------------------------------------------- vec3 fresnelSchlick(float cosTheta, vec3 F0) { return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0); } // ---------------------------------------------------------------------------- void main() { vec3 N = normalize(Normal); vec3 V = normalize(camPos - WorldPos); // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow) vec3 F0 = vec3(0.04); F0 = mix(F0, albedo, metallic); // reflectance equation vec3 Lo = vec3(0.0); for(int i = 0; i \u003c 4; ++i) { // calculate per-light radiance vec3 L = normalize(lightPositions[i] - WorldPos); vec3 H = normalize(V + L); float distance = length(lightPositions[i] - WorldPos); float attenuation = 1.0 / (distance * distance); vec3 radiance = lightColors[i] * attenuation; // Cook-Torrance BRDF float NDF = DistributionGGX(N, H, roughness); float G = GeometrySmith(N, V, L, roughness); vec3 F = fresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0); vec3 numerator = NDF * G * F; float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001; // + 0.0001 to prevent divide by zero vec3 specular = numerator / denominator; // kS is equal to Fresnel vec3 kS = F; // for energy conservation, the diffuse and specular light can't // be above 1.0 (unless the surface emits light); to preserve this // relationship the diffuse component (kD) should equal 1.0 - kS. vec3 kD = vec3(1.0) - kS; // multiply kD by the inverse metalness such that only non-metals // have diffuse lighting, or a linear blend if partly metal (pure metals // have no diffuse light). kD *= 1.0 - metallic; // scale light by NdotL float NdotL = max(dot(N, L), 0.0); // add to outgoing radiance Lo Lo += (kD * albedo / PI + specular) * radiance * NdotL; // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again } // ambient lighting (note that the next IBL tutorial will replace // this ambient lighting with environment lighting). vec3 ambient = vec3(0.03) * albedo * ao; vec3 color = ambient + Lo; // HDR tonemapping color = color / (color + vec3(1.0)); // gamma correct color = pow(color, vec3(1.0/2.2)); FragColor = vec4(color, 1.0); } Albedo（反照率） Metallic（金属度） Roughness（粗糙度） AO（环境光遮蔽） ","date":"2025-02-22","objectID":"/lighting/:4:3","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"IBL（Image based lighting） 是一类光照技术的集合。其光源不是如前一节教程中描述的可分解的直接光源，而是将周围环境整体视为一个大光源 将周围环境视为一个大光源 需要解决的问题： 多光源下，需要给定任意方向向量$w_i$，我们需要一些方法来获取这个方向上场景的辐射度 解决积分需要快速且实时 ","date":"2025-02-22","objectID":"/lighting/:5:0","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"HDR 等距圆柱投影转换为立方体贴图 #version 330 core out vec4 FragColor; in vec3 WorldPos; uniform sampler2D equirectangularMap; const vec2 invAtan = vec2(0.1591, 0.3183); vec2 SampleSphericalMap(vec3 v) { vec2 uv = vec2(atan(v.z, v.x), asin(v.y)); uv *= invAtan; uv += 0.5; return uv; } void main() { vec2 uv = SampleSphericalMap(normalize(WorldPos)); vec3 color = texture(equirectangularMap, uv).rgb; FragColor = vec4(color, 1.0); } 对于 IBL，假设$p$处于环境贴图中心，此时积分只依赖于$\\omega_i$,此时可近似为 $$L_o(p,\\omega_o) = L_d(\\omega_o) + L_s(\\omega_o)$$ 对于实时渲染，需要分别预计算漫反射项和镜面项 漫反射积分项 $$L_o(p,\\omega_o) = k_d\\frac{c}{\\pi} \\int\\limits_{\\Omega} L_i(p,\\omega_i) n \\cdot \\omega_i d\\omega_i$$ 此时的积分项只取决于不同的$n$ 镜面反射积分项 $$ L_o(p,\\omega_o) = \\int\\limits_{\\Omega} (k_s\\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)} L_i(p,\\omega_i) n \\cdot \\omega_i d\\omega_i = \\int\\limits_{\\Omega} f_r(p, \\omega_i, \\omega_o) L_i(p,\\omega_i) n \\cdot \\omega_i d\\omega_i $$ 近似处理后可以表示为 $$ L_o(p,\\omega_o) = \\int\\limits_{\\Omega} L_i(p,\\omega_i) d\\omega_i * \\int\\limits_{\\Omega} f_r(p, \\omega_i, \\omega_o) n \\cdot \\omega_i d\\omega_i $$ 第一部分为预滤波环境贴图，第二部分为BRDF积分贴图 ","date":"2025-02-22","objectID":"/lighting/:5:1","tags":null,"title":"Lighting","uri":"/lighting/"},{"categories":null,"content":"Shadow ","date":"2025-02-22","objectID":"/shadowmap/:0:0","tags":null,"title":"Shadow","uri":"/shadowmap/"},{"categories":null,"content":"光照贴图 ","date":"2025-02-22","objectID":"/shadowmap/:1:0","tags":null,"title":"Shadow","uri":"/shadowmap/"},{"categories":null,"content":"Shadow Map Shadow Map存在的问题： Shadow Acne Shadow Bias float ShadowCalculation(vec4 fragPosLightSpace) { // 执行透视除法，将裁切空间坐标的范围-w到w转为-1到1。当使用正交投影矩阵，顶点w元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行。 vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; // 变换到[0,1]的范围 projCoords = projCoords * 0.5 + 0.5; // 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标) float closestDepth = texture(shadowMap, projCoords.xy).r; // 取得当前片段在光源视角下的深度 float currentDepth = projCoords.z; // 检查当前片段是否在阴影中 float shadow = currentDepth \u003e closestDepth ? 1.0 : 0.0; return shadow; } ","date":"2025-02-22","objectID":"/shadowmap/:2:0","tags":null,"title":"Shadow","uri":"/shadowmap/"},{"categories":null,"content":"PCF float shadow = 0.0; vec2 texelSize = 1.0 / textureSize(shadowMap, 0); for(int x = -1; x \u003c= 1; ++x) { for(int y = -1; y \u003c= 1; ++y) { float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; shadow += currentDepth - bias \u003e pcfDepth ? 1.0 : 0.0; } } shadow /= 9.0; ","date":"2025-02-22","objectID":"/shadowmap/:2:1","tags":null,"title":"Shadow","uri":"/shadowmap/"},{"categories":null,"content":"参考资料 实时阴影技术（1）Shadow Mapping ","date":"2025-02-22","objectID":"/shadowmap/:3:0","tags":null,"title":"Shadow","uri":"/shadowmap/"},{"categories":["math"],"content":"抽象代数 ","date":"2024-02-26","objectID":"/basic_concepts/:0:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"1.1 群 满足四个性质： 封闭性：对于任意的$a,b\\in G$，都有$a\\circ b\\in G$。 结合律：对于任意的$a,b,c\\in G$，都有$(a\\circ b)\\circ c=a\\circ(b\\circ c)$。 幺元：存在一个元素$e\\in G$，使得对于任意的$a\\in G$，都有$e\\circ a=a\\circ e=a$。 逆元：对于任意的$a\\in G$，都存在一个元素$b\\in G$，使得$a\\circ b=b\\circ a=e$。 可以看到群并没有要求交换律。如果群内任意元素均满足$a\\circ b=b\\circ a$，则称该群为阿贝尔群。 半群： 满足封闭性和结合律，但不满足幺元和逆元。 ","date":"2024-02-26","objectID":"/basic_concepts/:1:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"1.2 群的同构和同态 同构： 若群$G$和$H$之间存在一个双射$\\varphi:G\\to H$,使得$f(a)=A$和$f(b)=B$，则有$f(a\\circ b)=f(a)\\ast f(b)$。 例：群$G(\\mathbb{Z}/4\\mathbb{Z},+)$和群$H(\\left\\{1,i,-1,-i\\right\\},\\times)$同构。 同态： 给定两个群$(G,\\circ)$和$(H,\\ast)$，如果存在一个映射$\\varphi:G\\to H$，使得对于任意的$a,b\\in G$，都有$\\varphi(a\\circ b)=\\varphi(a)\\ast\\varphi(b)$，那么称$\\varphi$是一个群的同态。因此可以说，同构是满足双射的同态 例1：$f(x)=x^2$是一个从实数到非负实数的同态。 例2：C3循环群和S3交换群同态，C3循环群和C6循环群同态 ","date":"2024-02-26","objectID":"/basic_concepts/:2:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"1.3 常见群 常见矩阵群： 一般线性群$GL(n)$:其单位元为单位矩阵，逆元为一个矩阵的逆矩阵。 特殊正交群$SO(n)$: 特殊欧式群$SE(n)$: 特殊射影群$SP(n)$ 循环群： 交换群\r对称群：n个对象所有的重新排列组成对称群$S_n$，可参考(https://zhuanlan.zhihu.com/p/402197369) ","date":"2024-02-26","objectID":"/basic_concepts/:3:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"环 2.1 环的定义 如果一个非空集合$R$上定义了两个二元运算$+$和$\\times$，分别称为加法和乘法，满足： （1）$(R,+)$是阿贝尔群 （2）$(R,\\times)$是半群 （3）乘法对于加法满足左分配律、右分配律，则称$R$ 关于运算$\\times$，$+$构成一个环（ring），记为$(R,+,\\times)$ ","date":"2024-02-26","objectID":"/basic_concepts/:4:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"域 ","date":"2024-02-26","objectID":"/basic_concepts/:5:0","tags":["math"],"title":"Abstract Algebra","uri":"/basic_concepts/"},{"categories":["math"],"content":"李群 李群指具有群结构的光滑微分流形，在物理上描述的是连续的对称性 例： 对于模为1的复数集合，其可以表示为$e^{i\\theta}$，显然该集合对于乘法封闭，满足群的四个基本要求，所以说其具有群结构。 相对应的这个集合可以在复平面上绘制成一个圆，此时，圆上的任意一点，都可以用赋予其的值$\\theta$表示其坐标，其等价于一个一维流形，且其上的乘法运算是光滑的，因此这个集合是一个李群 李代数：李群上的切空间。描述了李群的局部性质李代数由一个集合$V$，一个数域$F$ 和一个二元运算 $[,]$ 组成。如果它们满足以下几条性质，称 (V; F; [, ]) 为一个李代数，记作 g。 封闭性: $\\forall \\mathbf{X}, \\mathbf{Y} \\in V,[\\mathbf{X}, \\mathbf{Y}] \\in V$ 双线性: $\\forall \\mathbf{X}, \\mathbf{Y}, \\mathbf{Z} \\in V, a, b \\in F$ ，有$[a \\mathbf{X}+b \\mathbf{Y}, \\mathbf{Z}]=a[\\mathbf{X}, \\mathbf{Z}]+[\\mathbf{Y}, \\mathbf{Z}],[\\mathbf{Z}, a \\mathbf{X}+b \\mathbf{Y}]=a[\\mathbf{Z}, \\mathbf{X}]+b[\\mathbf{Z}, \\mathbf{Y}]$ 自反性: $\\forall \\mathbf{X} \\in V,[\\mathbf{X}, \\mathbf{X}]=\\mathbf{0}$ 雅可比等价: $\\forall \\mathbf{X}, \\mathbf{Y}, \\mathbf{Z} \\in V,[\\mathbf{X},[\\mathbf{Y}, \\mathbf{Z}]]+[\\mathbf{Z},[\\mathbf{X}, \\mathbf{Y}]]+[\\mathbf{Y},[\\mathbf{Z}, \\mathbf{X}]]=\\mathbf{0}$ 其中的二元运算称为李括号，他表示了两个元素之间的差异，在$R^3$空间中上定义的叉积就是一种李括号，此时$g=(R^3,R,\\times)$构成了李代数 指数映射：将切空间上的切向量映射到流形上点的动作 对数映射：将流形上的点映射到切空间的切向量上 ","date":"2024-02-26","objectID":"/lie_group/:0:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"O(2) ","date":"2024-02-26","objectID":"/lie_group/:1:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"SO(2) ","date":"2024-02-26","objectID":"/lie_group/:2:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"SU(2) 对于单位四元数$a+bi+cj+dk$ 其左乘矩阵形式等价于$\\left[\\begin{array}{ccc}a \u0026 -b \u0026 -c \u0026 -d \\\\ b \u0026 a \u0026 -d \u0026 c \\\\ c \u0026 d \u0026 a \u0026 -b \\\\ d \u0026 -c \u0026 -b \u0026 -a\\end{array}\\right]$，右乘矩阵等价为$\\left[\\begin{array}{ccc}a \u0026 -b \u0026 -c \u0026 -d \\\\ b \u0026 a \u0026 d \u0026 -c \\\\ c \u0026 -d \u0026 a \u0026 b \\\\ d \u0026 c \u0026 -b \u0026 a\\end{array}\\right]$，以右乘矩阵为例，其每个子矩阵代表了一个复数，如果将其改写为复数矩阵，形式为$\\left[\\begin{array}{ccc}a+bi \u0026 -c+di\\\\ c + di \u0026 a-bi\\end{array}\\right]$此时，该矩阵为酉矩阵。且对于单位四元数，该矩阵的特征值为1。 $\\operatorname{SU}(2)$群是一个矩阵群，群元素为$2\\times2$的幺正矩阵，且行列式为1 ","date":"2024-02-26","objectID":"/lie_group/:3:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"SO(3) 对于旋转，它只有三个自由度，但是使用旋转矩阵就会有9个量，显然使用旋转矩阵表达旋转是冗余的，理论上可以用3个量来表示旋转. $\\operatorname{SO}(3)$ 群是一个常见的李群，若将$\\operatorname{SO}(3)$群视为全体三维空间中，顺时针转动任意角度的集合，有： $$\\operatorname{SO}(3) \\equiv \\left\\{\\begin{array}{l|l} \\mathcal{R}(\\vec{\\omega}) \u0026 \\begin{array}{l} \\vec{\\omega}=\\omega \\vec{n}, \\vec{n}=(\\cos \\varphi \\sin \\theta, \\sin \\varphi \\sin \\theta, \\cos \\theta) \\\\ \\omega \\in[0, \\pi], \\theta \\in[0, \\pi], \\varphi \\in[0,2 \\pi] \\end{array} \\end{array}\\right\\}$$ 在式$\\vec{\\omega}=\\omega \\vec{n}$中，$\\vec{n}$是旋转轴，模长为1，$\\omega$是绕$\\vec{n}$旋转的角度。 $\\mathcal{R}(\\vec{\\omega})$表示绕$\\vec{\\omega}$轴旋转$\\omega$角度的操作。 因此，我们可以将$\\operatorname{SO}(3)$群视作由$\\vec{\\omega}$端点构成的半径为$\\pi$的实心球 ","date":"2024-02-26","objectID":"/lie_group/:4:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"从SO(3)群推导罗德里格斯公式 对于三维旋转群$\\operatorname{SO}(3)$，其集合内元素满足 $$\\det R=1$$ $$R^TR=I$$ 若考虑其为时间$t$的函数，则有$\\mathbf{R}(t)^T\\mathbf{R}(t)=\\mathbf{I}$。对其求导，有 $$\\dot{\\mathbf{R}}(t) \\mathbf{R}(t)^T+\\mathbf{R}(t) \\dot{\\mathbf{R}}(t)^T=0$$ $$\\dot{\\mathbf{R}}(t) \\mathbf{R}(t)^T=-\\mathbf{R}(t) \\dot{\\mathbf{R}}(t)^T$$ 不难发现，$\\mathbf{R}(t) \\dot{\\mathbf{R}}(t)^T$是一个反对称矩阵。因此，我们可以将其记作${\\mathbf{A}}$，对于这个$3\\times 3$反对称矩阵，其对角线元素为0，因此其只有三个自由度，可以将其对应于三维向量$\\mathbf{a} = [a_1, a_2, a_3]^T$，因此对于矩阵A我们可以将其表示为： $$\\mathbf{a}^{\\wedge} = \\mathbf{A}=\\begin{bmatrix} 0 \u0026 -a_3 \u0026 a_2 \\\\ a_3 \u0026 0 \u0026 -a_1 \\\\ -a_2 \u0026 a_1 \u0026 0 \\end{bmatrix}$$ 其中$\\mathbf{a}^{\\wedge}$表示$\\mathbf{a}$所对应的反对称矩阵。因此我们使用$\\phi(t)^{\\wedge}$对应$\\dot{\\mathbf{R}}(t) \\mathbf{R}(t)^T$,即： $$\\dot{\\mathbf{R}}(t) \\mathbf{R}(t)^T=\\phi(t)^{\\wedge}$$ 此时，$$\\dot{\\mathbf{R}}(t)=\\phi(t)^{\\wedge} \\mathbf{R}(t)=\\left[\\begin{array}{ccc}0 \u0026 -\\phi_3 \u0026 \\phi_2 \\\\ \\phi_3 \u0026 0 \u0026 -\\phi_1 \\\\ -\\phi_2 \u0026 \\phi_1 \u0026 0\\end{array}\\right] \\mathbf{R}(t)$$ 不难发现其对应于关于$\\mathbf{R}$的微分方程： $$\\mathbf{R}(t)=\\exp \\left(\\phi(t)^{\\wedge}\\right) \\mathbf{R}\\left(t_0\\right)$$ 任意矩阵的指数映射可以使用泰勒展开进行近似，对于$\\exp \\left(\\phi(t)^{\\wedge}\\right)$，我们可以使用泰勒展开进行近似： $$\\exp \\left(\\phi(t)^{\\wedge}\\right)=\\mathbf{I}+\\phi(t)^{\\wedge}+\\frac{\\left(\\phi(t)^{\\wedge}\\right)^2}{2 !}+\\frac{\\left(\\phi(t)^{\\wedge}\\right)^3}{3 !}+\\cdots$$ 对于三维向量$\\phi$，可以使用,假设其模长为$\\theta$,方向为$a$，即$\\phi=\\theta {a}$，因此$\\phi^{\\wedge}=\\theta {a}^{\\wedge}$。 且有两个性质： $$ \\begin{aligned} \u0026 a^{\\wedge} a^{\\wedge}=a a^T-I \\\\ \u0026 a^{\\wedge} a^{\\wedge} a^{\\wedge}=-a^{\\wedge} \\end{aligned} $$ 因此上式可展开为： $$ \\begin{aligned} \u0026 \\mathbf{R}=\\exp \\left(\\phi^{\\wedge}\\right)=\\exp \\left(\\theta a^{\\wedge}\\right)=\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\theta a^{\\wedge}\\right)^n \\\\ \u0026 =I+\\theta a^{\\wedge}+\\frac{1}{2 !} \\theta^2 a^{\\wedge} a^{\\wedge}+\\frac{1}{3 !} \\theta^3 a^{\\wedge} a^{\\wedge} a^{\\wedge}+\\frac{1}{4 !} \\theta^4\\left(a^{\\wedge}\\right)^4+\\ldots \\\\ \u0026 =a a^T-a^{\\wedge} a^{\\wedge}+\\theta a^{\\wedge}+\\frac{1}{2 !} \\theta^2 a^{\\wedge} a^{\\wedge}-\\frac{1}{3 !} \\theta^3 a^{\\wedge}-\\frac{1}{4 !} \\theta^3\\left(a^{\\wedge}\\right)^2+\\ldots \\\\ \u0026 =a a^T+\\left(\\theta-\\frac{1}{3 !} \\theta^3+\\frac{1}{5 !} \\theta^5-\\ldots\\right) a^{\\wedge}-\\left(1-\\frac{1}{2 !} \\theta^2+\\frac{1}{4 !} \\theta^4-\\ldots\\right) a^{\\wedge} a^{\\wedge} \\\\ \u0026 =a^{\\wedge} a^{\\wedge}+I \\sin \\theta a^{\\wedge}-\\cos \\theta a^{\\wedge} a^{\\wedge} \\\\ \u0026 =(1-\\cos \\theta) a^{\\wedge} a^{\\wedge}+I+\\sin \\theta a^{\\wedge} \\\\ \u0026 =\\cos \\theta I+(1-\\cos \\theta) a a^T+\\sin \\theta a^{\\wedge} \\end{aligned} $$ $\\operatorname{SO}(3)$李代数：物理意义为旋转向量 $$ \\mathfrak{so}(3)=\\left\\{\\phi \\in \\mathbb{R}^3, \\boldsymbol{\\Phi}=\\boldsymbol{\\phi}^{\\wedge} \\in \\mathbb{R}^{3 \\times 3}\\right\\} . $$ 四元数插值 Nlerp Slerp $\\operatorname{SU}(2)$ ","date":"2024-02-26","objectID":"/lie_group/:5:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"SE(3) $\\operatorname{SE(3)}$群是一个六维李群，它是三维旋转群$\\operatorname{SO(3)}$和三维平移群$\\mathbb{R}^3$的直积，即： $$\\begin{equation} \\operatorname{SE(3)}= \\left\\{\\left[\\begin{array}{ccc}\\mathbf{R} \u0026 \\mathbf{P} \\\\ \\mathbf{0} \u0026 1\\end{array}\\right]\\mathbf{P} \\in \\mathbb{R}^3, \\mathbf{R} \\in \\operatorname{SO(3)} \\right\\} \\end{equation}$$ 作为矩阵李群，$\\operatorname{SE(3)}$代表一种齐次坐标变换，可以代表某种刚体运动的集合 对偶四元数插值： $$ \\operatorname{DQLERP}\\left(Q_0, Q_1, t\\right):=\\frac{Q_0+t\\left(Q_1-Q_0\\right)}{\\left||Q_0+t\\left(Q_1-Q_0\\right)|\\right|} $$ $\\operatorname{ScLERP}$插值，SE(3)中Q0到Q1的测地线 ","date":"2024-02-26","objectID":"/lie_group/:6:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["math"],"content":"李群的旋转插值 ","date":"2024-02-26","objectID":"/lie_group/:7:0","tags":["math"],"title":"Lie Group","uri":"/lie_group/"},{"categories":["GPU","Algorithm"],"content":"Distance Computation ","date":"2024-01-26","objectID":"/gpu-distance/:0:0","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"CPU上的离散模型距离计算库 FCL #include \u003cfcl/fcl.h\u003e typedef fcl::BVHModel\u003cfcl::OBBRSS\u003cREAL\u003e\u003e FCLModel; std::vector\u003cfcl::Vector3\u003cREAL\u003e\u003e fclVerticesA, fclVerticesB; std::vector\u003cfcl::Triangle\u003e fclTrianglesA, fclTrianglesB; std::shared_ptr\u003cFCLModel\u003e geomA = std::make_shared\u003cFCLModel\u003e(); std::shared_ptr\u003cFCLModel\u003e geomB = std::make_shared\u003cFCLModel\u003e(); FCLModel* FCLModelA, *FCLModelB; fcl::CollisionObject\u003cREAL\u003e* objA = new fcl::CollisionObject\u003cREAL\u003e(geomA, transformA); fcl::CollisionObject\u003cREAL\u003e* objB = new fcl::CollisionObject\u003cREAL\u003e(geomB, transformB); fcl::DistanceRequest\u003cREAL\u003e request; request.enable_nearest_points = true; fcl::DistanceResult\u003cREAL\u003e result; fcl::distance(objA, objB, request, result); PQP #include \"PQP.h\" PQP_Model* modelA, * modelB; PQP_REAL RA[3][3] = { rotA._data[0], rotA._data[3],rotA._data[6],rotA._data[1],rotA._data[4] ,rotA._data[7] ,rotA._data[2] ,rotA._data[5] ,rotA._data[8] }; PQP_REAL OFFA[3] = { offsetA.x, offsetA.y, offsetA.z }; PQP_REAL RB[3][3] = { rotB._data[0], rotB._data[3],rotB._data[6],rotB._data[1],rotB._data[4] ,rotB._data[7] ,rotB._data[2] ,rotB._data[5] ,rotB._data[8] }; PQP_REAL OFFB[3] = { offsetB.x, offsetB.y, offsetB.z }; PQP_DistanceResult dres; PQP_Distance(\u0026dres, RA, OFFA, modelA, RB, OFFB, modelB, 0.0, 0.0); SSE SSE只提供了三角形计算的代码，且其中有部分有问题？目前修改了一版基于embree的可用的SSE代码 ","date":"2024-01-26","objectID":"/gpu-distance/:1:0","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"贝塞尔曲线的最小距离计算 参考Sum-of-square ccd的方法，计算贝塞尔曲线的距离 以下为matlab代码 % u1是第一条贝塞尔曲线的参数，v1是第二条贝塞尔曲线的参数 sdpvar u1 v1 lambda; % 默认两条都是三次贝塞尔曲线 d = 3; % 分别为Bcurve1和Bcurve2的控制点 pta0 = [0;0;0]; pta1 = [8;0;0]; pta2 = [8;8;0]; pta3 = [0;8;0]; ptb0 = [-8;0;0]; ptb1 = [0;0;0]; ptb2 = [0;8;0]; ptb3 = [-8;8;0]; Bcurve1 = (1-u1)^3*pta0 + 3*(1-u1)^2*u1*pta1 + 3*(1-u1)*u1^2*pta2 + u1^3*pta3; Bcurve2 = (1-v1)^3*ptb0 + 3*(1-v1)^2*v1*ptb1 + 3*(1-v1)*v1^2*ptb2 + v1^3*ptb3; % sos约束数量取决于不等式约束的数量 gi = [u1*(1-u1); v1*(1-v1)]; [s1, s1c] = polynomial(u1, d); [s2, s2c] = polynomial(u1, d); % 待优化函数f 此处为距离函数 f = (Bcurve2 - Bcurve1)' * (Bcurve2 - Bcurve1); C1 = [sos(s1); sos(s2)]; C2 = sos(f-lambda-[s1, s2] * gi); F = [C1, C2]; [C, obj] = sosmodel(F, -lambda, [], [s1c; s2c; lambda]); optimize(C, obj, []); value(lambda) % lstar = value(lambda); % mu = dual(C(2)); % ustar = mu(3:4)/mu(1); % value(ustar) ","date":"2024-01-26","objectID":"/gpu-distance/:2:0","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"GPU distance computation ","date":"2024-01-26","objectID":"/gpu-distance/:3:0","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"AABB包围盒的距离上下界 ","date":"2024-01-26","objectID":"/gpu-distance/:3:1","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"BVTT的扩展 每个BVTT存储来自两颗BVH树中的两个节点，并在自适应深度下，生成自己的四个bvtt子节点，计算其bounding box的距离上下界，然后根据这个距离上下界，决定是否需要进一步的深度计算。 选择使用SoA的方式存储BVTT，这样可以更好的利用内存的连续性，提高访存效率 __host__ __device__ struct g_bvtt{ int* id1; int* id2; float* min; }; ","date":"2024-01-26","objectID":"/gpu-distance/:3:2","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"自适应深度计算 对于一个有n个BVTT的buffer，需要计算其最大可扩展深度k，使其满足$2^{2k}n=C$，当k小于1时，取k=1，即采取传统策略 根据节点数对扩展的层数进行动态的调整，当缓冲区包含了n个BVTT节点时，自适应展开算法的目标通常是一个常数c，我们需要找到一个合适的展开层数k，在实际应用中，取常数c为$1024\\times256$ __host__ __device__ int calProDeep(int maxDeepA, int maxDeepB, int bvttLength, int deepNow) ","date":"2024-01-26","objectID":"/gpu-distance/:3:3","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"Parallel Culling 在每次迭代中，我们计算得到的每个BVTT节点中两个BVH节点的边界框之间的最小最大距离。随后，我们执行一个缩减操作来确定这些最大值中的最小值。然后将这个最小值作为最小距离的估计值。在后续的迭代中，所有边界框距离超过这个估计距离的BVTT节点都可以被有效地消除。这种筛选机制确保了在整个算法中对BVTT节点的控制和优化进程。 ","date":"2024-01-26","objectID":"/gpu-distance/:3:4","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"吞吐量 当buffer中的BVTT节点过少时，如何充分利用硬件的计算资源 传统的遍历方法通常为每个现有的BVTT节点分配一个线程，每个线程负责单个BVTT节点的扩展。虽然这种方法是标准的，特别是在前面描述的消除算法的距离计算中，但它往往没有充分利用GPU的资源，因为在每个内核调用中只处理有限数量的线程。 分配一个bvtt节点到多个对应线程中 考虑到一个bvtt节点最多有4个对应的子节点， 将一个BVTT节点分配到多个线程中， const int tid = blockDim.x * blockIdx.x + threadIdx.x; int id1, id2; id1 = bvttNode.id1[tid \u003e\u003e 2]; id2 = bvttNode.id2[tid \u003e\u003e 2]; ","date":"2024-01-26","objectID":"/gpu-distance/:3:5","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"最小距离的维护 然后使用cub库的BlockReduce原子操作获得一个block内的最小值，然后使用atomicMin原子操作获得全局的最小值 // 基于浮点数的atomicMin操作 inline __device__ float atomicMin(float* address, float val) { int* address_as_i = (int*)address; int old = *address_as_i, assumed; do { assumed = old; old = ::atomicCAS(address_as_i, assumed, __float_as_int(::fminf(val, __int_as_float(assumed)))); } while (assumed != old); return __int_as_float(old); } ","date":"2024-01-26","objectID":"/gpu-distance/:3:6","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":["GPU","Algorithm"],"content":"BVH的重新构建 Why？ 对BVH树，需要进行调整，使其可以快速搜索到自己的所有第k层的后代节点 1.基于Mortan Code构建一颗完整二叉的BVH，其叶子节点包含一个或者两个primitive 2.而且相邻线程都是访问相同的或者相邻的BVTT，从而使得gpu上的内存访问基本是合并内存访问 ","date":"2024-01-26","objectID":"/gpu-distance/:3:7","tags":["GPU"],"title":"distance computation","uri":"/gpu-distance/"},{"categories":null,"content":"基于热的测地线距离以及向量平行传输 ","date":"2023-10-08","objectID":"/heatmethod/:0:0","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"heat method $\\phi(x,y) = \\lim _{t \\rightarrow 0} \\sqrt{-4t \\log {k_t}(x,y)} $ 当热核函数存在误差的时候，直接使用Varadhan公式会有非常显著的误差。 ","date":"2023-10-08","objectID":"/heatmethod/:1:0","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"Alg 在曲面上给定一点x上施加一个热源，并对其进行扩散获得温度场 1.$\\frac{d}{dt}u = \\Delta u$ 取u为顶点坐标的函数，代入热传导方程并离散化后有$\\frac{u^{k+1} - u^k}{h} = Lu^k$,隐式迭代下为$(I-tL)u^{k+1} = u^k$。此时，$u_0$代表 可以使用Cholesky分解或者Krylov子空间分解，在论文中，t的选取一般取平均边长的平方 2.$X = -\\frac{\\nabla u}{|\\nabla u|}$ 对温度场的梯度进行归一化后得到距离场扩散的向量场X 3.求解$\\Delta u = \\nabla \\cdot X$ 对于已知向量场X，如果希望寻找一个势场u使得u可以表示X，则可以构造迪利克雷能量 $E(u)=\\int_{M}|\\nabla u-X|^{2} d A$。 而最小化迪利克雷能量等价于求解泊松方程$\\Delta u = \\nabla \\cdot X$ /* Constructor * Input: The surface mesh \u003cinputMesh\u003e and geometry \u003cinputGeo\u003e. */ HeatMethod::HeatMethod(ManifoldSurfaceMesh* surfaceMesh, VertexPositionGeometry* geo) { this-\u003emesh = surfaceMesh; this-\u003egeometry = geo; // TODO: Build Laplace and flow matrices. double h = this-\u003egeometry-\u003emeanEdgeLength(); int N = mesh-\u003enVertices(); SparseMatrix\u003cdouble\u003e M = geometry-\u003emassMatrix(); // Note: core/geometry.cpp has meanEdgeLength() function this-\u003eA = geometry-\u003elaplaceMatrix(); this-\u003eF = M + h * h * A; } /* * Computes the vector field X = -∇u / |∇u|. * * Input: \u003cu\u003e, a dense vector representing the heat that is allowed to diffuse on the input mesh for a brief period of * time. * Returns: A MeshData container that stores a Vector3 per face. */ FaceData\u003cVector3\u003e HeatMethod::computeVectorField(const Vector\u003cdouble\u003e\u0026 u) const { FaceData\u003cVector3\u003e vf(*mesh, {0, 0, 0}); for (Face f : mesh-\u003efaces()) { Vector3 grad{0, 0, 0}; Vector3 normal = geometry-\u003efaceNormal(f); for (Halfedge he : f.adjacentHalfedges()) { Vector3 ePerp = geometry-\u003einputVertexPositions[he.next().tipVertex()] - geometry-\u003einputVertexPositions[he.next().tailVertex()]; ePerp = ePerp.rotateAround(normal, M_PI / 2); grad += ePerp * u[he.vertex().getIndex()]; } vf[f.getIndex()] = -grad.normalizeCutoff(); } return vf; } /* * Computes the integrated divergence ∇.X. * * Input: \u003cX\u003e, the vector field -∇u / |∇u| represented as a FaceData container * Returns: A dense vector */ Vector\u003cdouble\u003e HeatMethod::computeDivergence(const FaceData\u003cVector3\u003e\u0026 X) const { Vector\u003cdouble\u003e div = Vector\u003cdouble\u003e::Zero(mesh-\u003enVertices()); for (Face f : mesh-\u003efaces()) { Vector3 Xj = X[f.getIndex()]; for (Halfedge he : f.adjacentHalfedges()) { Vector3 e = geometry-\u003einputVertexPositions[he.tipVertex()] - geometry-\u003einputVertexPositions[he.tailVertex()]; double val = 0.5 * geometry-\u003ecotan(he) * dot(e, Xj); div[he.tailVertex().getIndex()] += val; div[he.tipVertex().getIndex()] += -val; } } return div; // placeholder } /* * Computes the geodesic distances φ using the heat method. * * Input: \u003cdelta\u003e, a dense vector representing the heat sources, i.e., u0 = δ(x). Returns: A dense vector containing the * geodesic distances per vertex. */ Vector\u003cdouble\u003e HeatMethod::compute(const Vector\u003cdouble\u003e\u0026 delta) const { Eigen::SimplicialLLT\u003cSparseMatrix\u003cdouble\u003e\u003e llt(F); Vector\u003cdouble\u003e u = llt.solve(delta); FaceData\u003cVector3\u003e X = computeVectorField(u); Vector\u003cdouble\u003e deltaPhi = computeDivergence(X); SparseMatrix\u003cdouble\u003e A = this-\u003eA; geometrycentral::PositiveDefiniteSolver\u003cdouble\u003e solver(A); Vector\u003cdouble\u003e phi = solver.solve(-deltaPhi); // Since φ is unique up to an additive constant, it should be shifted such that the smallest distance is zero this-\u003esubtractMinimumDistance(phi); return phi; } ","date":"2023-10-08","objectID":"/heatmethod/:1:1","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"cotLaplacain推导 (https://zhuanlan.zhihu.com/p/372670140) ","date":"2023-10-08","objectID":"/heatmethod/:1:2","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"处理点云模型或者多边形模型 ","date":"2023-10-08","objectID":"/heatmethod/:1:3","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"距离光顺 ","date":"2023-10-08","objectID":"/heatmethod/:1:4","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"边界条件处理 1.迪利克雷条件 若泊松方程只存在迪利克雷边界，则只需将网格边界和内部分开来考虑即可 $$\\left[\\begin{array}{ll} L_{I I} \u0026 L_{I B} \\\\ L_{B I} \u0026 L_{B B} \\end{array}\\right]\\left[\\begin{array}{l} u_I \\\\ u_B \\end{array}\\right]=\\left[\\begin{array}{cc} M_I \u0026 0 \\\\ 0 \u0026 M_B \\end{array}\\right]\\left[\\begin{array}{l} f_I \\\\ f_B \\end{array}\\right]$$ 2.纽曼条件 对于nuemann边界条件，$(\\Delta u)_i=\\frac{1}{2}\\left(g_a+g_b\\right)+\\frac{1}{2} \\sum_j\\left(\\cot \\alpha_j+\\cot \\beta_j\\right)\\left(u_j-u_i\\right)$ 其中$g_a$和$g_b$分别代表给定方向导数在边界上的积分。 泊松方程可以表示为 $$\\left[\\begin{array}{ll} L_{I I} \u0026 L_{I B} \\\\ L_{B I} \u0026 L_{B B} \\end{array}\\right]\\left[\\begin{array}{l} u_I \\\\ u_B \\end{array}\\right]=\\left[\\begin{array}{l} M_If_I \\\\ M_Bf_B-g \\end{array}\\right]$$ 此时按照无边界条件处理 对于HeatMethod，使用平均边界条件$u = (u_N + u_D)$ ","date":"2023-10-08","objectID":"/heatmethod/:1:5","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"收敛性 ","date":"2023-10-08","objectID":"/heatmethod/:1:6","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"基于机器学习 对于一个嵌在$R^m$中的$d$维黎曼流形 1.将$V^0$沿着整个流形通过heat flow的方式进行传播获得流形上的向量场$V_s$ $$\\min_{V} E(V) :=\\int_{\\mathcal{M}}\\left|V-V^{0}\\right|^{2} d x+t \\int_{\\mathcal{M}}|\\nabla V|_{\\mathrm{HS}}^{2} d x$$ 2.向量场$V$归一化 3.最小化$\\Phi(f)$ $$min_{f}\\Phi(f):=\\int_{\\mathcal{M}}|\\nabla f-\\hat{V}|^{2} d x$$ $${ s.t. } f(p)=0$$ ","date":"2023-10-08","objectID":"/heatmethod/:1:7","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"heat method的并行 从热扩散方程中获得一个接近于单位向量场的可积分的梯度场，对该梯度场进行积分获得测地线距离 1.使用Gauss-Seidel迭代求解热扩散 $$u^{i}(v_j) = \\frac{u_{0}(v_{j})+t \\sum_{k\\in \\mathcal{N}_{j}} \\theta _{j,k} u^{i-1}(v _{k})}{A _{v_j} + t \\sum _{k\\in \\mathcal{N}(j)} \\theta _{j, k}} $$ 2.获得可积分向量场 在原Heat Method中通过最小化迪利克雷能量来获得一个标量场使其梯度近似于单位向量场$h_i$，而在并行时使用ADMM求解器求解一个凸优化问题从而获得一个可积分的向量场$g_i$ 凸优化问题 $$ \\min_{\\mathbf{g}_{i}} \\sum _{f_i \\in \\mathcal{F}} A_i\\left|\\mathbf{g}_i-\\mathbf{h}_i\\right|^{2} \\\\ \\text{s.t.} \\overline{\\mathbf{e}} \\cdot\\left(\\mathbf{g}_1^{e}-\\mathbf{g}_2^{e}\\right)=0 \\quad \\forall e \\in \\mathcal{E} _{\\text {int }} $$ 下式代表对于共边的两个面，他们面上的梯度向量和共同边的点积必定相等 3.对向量场$g_i$进行积分 $$d(v_j)=d(v_k) + \\frac{1}{\\left|\\mathcal{T}_ {j k}\\right|} \\sum_{f_l \\in \\mathcal{T}_ {j k}} \\mathbf{g}_ {l} \\cdot\\left(\\mathbf{p}_ j-\\mathbf{p}_ k\\right)$$ 多源最短路径 优点： Gauss-Seidel和ADMM都可以快速收敛 具有较低的内存占用，允许处理大网格 可并行性强 ","date":"2023-10-08","objectID":"/heatmethod/:1:8","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"可优化的部分 用GMRES求解线性方程组 时间t的选取 加权距离计算 ","date":"2023-10-08","objectID":"/heatmethod/:1:9","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"Vector Heat Method ","date":"2023-10-08","objectID":"/heatmethod/:2:0","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"Scalar Interpolation 使用高斯核插值 $$ G_t(x, y):=\\frac{1}{(4 \\pi t)^{n / 2}} e^{-d(x, y)^2 / 4 t} $$ $$ \\bar{u}_ t=\\frac{u_1 G_{t, p_1}+u_2 G_{t, p_2}}{G_{t, p_1}+G_{t, p_2}} $$ 当t趋于0时，$\\bar{u}_t$趋于$\\frac{u_1+u_2}{2}$ ","date":"2023-10-08","objectID":"/heatmethod/:2:1","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"Connection Laplacian ","date":"2023-10-08","objectID":"/heatmethod/:2:2","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"Vector Heat Method的并行分析 ","date":"2023-10-08","objectID":"/heatmethod/:2:3","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"拓展 流形M的选择，向量空间的选择，流形上平行的定义 例如：对于向量空间$V\\in R$，向量的平行传输就变为了scalar interpolation differential 1-forms，计算切丛 symmetric direction fields（对称方向场）向量场在每个点上的向量与通过该点的某条对称轴上的向量具有相同的方向 different connection ","date":"2023-10-08","objectID":"/heatmethod/:2:4","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":null,"content":"application 自由边界问题中推断scalar velocity和vector velocity（向量外推） logmap 径向向量场$R$ 平行向量场$H$ Karcher Means and Geometric Medianss ","date":"2023-10-08","objectID":"/heatmethod/:2:5","tags":null,"title":"Heat Method for Geodesic","uri":"/heatmethod/"},{"categories":["simulation"],"content":"fem概览 ","date":"2023-07-13","objectID":"/fem/:0:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"流程 1.获得微分方程 2.定义边界或者约束条件 3.将微分形式的控制方程转换为其等效积分 4.对计算单元刚度矩阵 5.单元刚度矩阵的组装 6.矩阵求解 ","date":"2023-07-13","objectID":"/fem/:1:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"等效变换 控制方程（微分形式）-\u003e 等效积分 -\u003e 等效积分的弱形式 变分形式推导 ","date":"2023-07-13","objectID":"/fem/:2:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"加权余量 给定微分方程 $$A(u) = 0$$ $$B(u) = 0$$ 能量泛函推导： $$A(u) = L(u) + f$$ $$\\int_{\\Omega}(L(u) + f)\\delta u \\ d\\Omega = 0$$ $$ \\begin{equation*} \\begin{split} \\int_{\\Omega}L(u)\\delta u \\ d\\Omega \u0026 = \\int_{\\Omega}\\frac{1}{2}L(u)\\delta u \\ d\\Omega + \\int_{\\Omega}\\frac{1}{2}L(u)\\delta u \\ d\\Omega \\\\ \u0026 = \\int_{\\Omega}\\frac{1}{2}L(u)\\delta u \\ d\\Omega + \\int_{\\Omega}\\frac{1}{2}L(\\delta u)u \\ d\\Omega \\\\ \u0026 = \\delta\\int_{\\Omega}\\frac{1}{2}L(u)u \\ d\\Omega \\end{split} \\end{equation*} $$ 其中A和B都是算子符号,$A(u)$为控制方程，$B(u)$为边界条件 其等效积分形式为 $$\\int wA(u)d\\Omega + \\int wB(u)d\\tau = 0$$ 当通过形函数进行近似时 $$\\tilde{u} = \\sum N_iu_i$$ $$A(\\tilde{u}) = R$$ Example: ","date":"2023-07-13","objectID":"/fem/:3:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"伽辽金法 用单元的形函数来代表等效积分中的权函数$w$使得残差尽可能小 $$\\int N A(\\tilde{u})d\\Omega + \\int NB(\\tilde{u})d\\tau = 0$$ ","date":"2023-07-13","objectID":"/fem/:3:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"其他方法 子域法，配点法，最小二乘法，力矩法 ","date":"2023-07-13","objectID":"/fem/:3:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"边界条件 对一个2m阶的微分方程，0到m-1阶为强制边界条件，m到2m-1为自然边界条件 强制边界条件（本质边界条件）：强加给控制方程必须满足的 自然边界条件：泛函一阶变分为零，在边界上必须满足的条件（一般在积分表达式中可以自动得到满足） 混合边界条件 ","date":"2023-07-13","objectID":"/fem/:4:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"Dirchlet边界条件 常微分条件下 在区间$\\left [ a,b \\right ]$,满足$y(a) = \\alpha, y(b) = \\beta$,其中$\\alpha,\\beta$为常数 偏微分条件下 $y(x) = f(x), \\forall x \\in \\partial \\Omega$,其中 $f$ 是在边界 $\\partial \\Omega$ 中定义的已知函数 Example： 机械：梁的一端保持在空间中的固定位置 热力学中：表面保持在固定温度\r流体力学：粘性流体的固液边界处，流体相对于边界具有零速度\r","date":"2023-07-13","objectID":"/fem/:4:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"Neumman边界条件 代求变量边界外法线的方向导数被指定 常微分条件下 在区间$\\left [ a,b \\right ]$,满足$y’(a) = \\alpha, y’(b) = \\beta$,其中$\\alpha,\\beta$为常数 偏微分条件下 Example： 热力学：热传导方程中边界绝热，内部热量无法通过边界传导到外部\r","date":"2023-07-13","objectID":"/fem/:4:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"Robin边界条件 ","date":"2023-07-13","objectID":"/fem/:4:3","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"施加约束 ","date":"2023-07-13","objectID":"/fem/:5:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"罚函数 P（比例）控制器 PD（比例微分）控制器 PID（比例积分微分）控制器 ","date":"2023-07-13","objectID":"/fem/:5:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"拉格朗日乘子法 ","date":"2023-07-13","objectID":"/fem/:5:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"函数内积 $\\int_{a}^{b}f(x)g(x)dx$记作$\\left \\langle f,g \\right \\rangle$称为函数内积 若$\\left \\langle f,g \\right \\rangle$在$\\left [ a,b \\right ]$上等于0，说明$\\left \\langle f,g \\right \\rangle$在$\\left [ a,b \\right ]$上正交 ","date":"2023-07-13","objectID":"/fem/:6:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"单元刚度矩阵的推导 ","date":"2023-07-13","objectID":"/fem/:7:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"偏微分法 ","date":"2023-07-13","objectID":"/fem/:7:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"变分法 ","date":"2023-07-13","objectID":"/fem/:7:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"静态分析中平衡方程求解 ","date":"2023-07-13","objectID":"/fem/:8:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"直接求解 ","date":"2023-07-13","objectID":"/fem/:8:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"迭代求解 Gauss-Seidel方法\r","date":"2023-07-13","objectID":"/fem/:8:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"非线性方程组求解 Newton-Raphson方法\rBFGS法\r载荷-位移-约束方法\r","date":"2023-07-13","objectID":"/fem/:8:3","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"动态分析中平衡方程求解 ","date":"2023-07-13","objectID":"/fem/:9:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"直接积分 中心差法\rHoubolt法\rNewmark法\rBathe法\r","date":"2023-07-13","objectID":"/fem/:9:1","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"模态叠加 ","date":"2023-07-13","objectID":"/fem/:9:2","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"与FVM，FDM的差别 对于FVM其权函数$w$为1 ","date":"2023-07-13","objectID":"/fem/:10:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"线性动态有限元 由于引入了时间坐标，因此问题变为二维$(x, t)$问题，采用部分离散的方法，即只将空间域进行离散 ","date":"2023-07-13","objectID":"/fem/:11:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":["simulation"],"content":"弹性体模拟 ","date":"2023-07-13","objectID":"/fem/:12:0","tags":["simulation"],"title":"FEM","uri":"/fem/"},{"categories":null,"content":"\r","date":"2023-06-09","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["simulation"],"content":"mesh ccd ","date":"2023-05-01","objectID":"/ccd/:0:0","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"基本概念 ","date":"2023-05-01","objectID":"/ccd/:1:0","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"false positives a collision is reported when there is no collision ","date":"2023-05-01","objectID":"/ccd/:1:1","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"false negatives a collision is not reported when there is a collision ","date":"2023-05-01","objectID":"/ccd/:1:2","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"Multivariate CCD Formulation $$\\begin{align*} \u0026F_{\\mathrm{vf}}(t, u, v)=p(t)-\\left((1-u-v) v_1(t)+u v_2(t)+v v_3(t)\\right)\\\\ \u0026F_{\\mathrm{vf}}: \\Omega_{\\mathrm{vf}}=[0,1] \\times\\{u, v \\geqslant 0 \\mid u+v \\leqslant 1\\} \\rightarrow \\mathbb{R}^3\\\\ \u0026F_{\\mathrm{ee}}(t, u, v)=\\left((1-u) p_1(t)+u p_2(t)\\right)-\\left((1-v) p_3(t)+v p_4(t)\\right)\\\\ \u0026F_{\\mathrm{ee}}: \\Omega_{\\mathrm{ee}}=[0,1] \\times[0,1]^2 \\rightarrow \\mathbb{R}^3 \\end{align*}$$ ","date":"2023-05-01","objectID":"/ccd/:1:3","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"Univariate CCD Formulation ","date":"2023-05-01","objectID":"/ccd/:1:4","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"Normal Cone test 给定连续曲面S以及其边界C，若其不自交，则必须通过surface normal test和contour test 1.存在一个向量$\\vec{v}$，使(N.v)\u003e 0对曲面上的任意点都成立 2.轮廓C沿向量v的投影在投影平面上没有任何自交。 struct cone { Eigen::Vector3f axis; float angle; // input two axis and get the one axis void set(Eigen::Vector3f axis1, Eigen::Vector3f axis2) { axis = normalized(axis1 + axis2); angle = acos(axis1.dot(axis2)) * 0.5; } }; ","date":"2023-05-01","objectID":"/ccd/:1:5","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"Continus Normal Cone $$\\mathbf{n}_{\\mathbf{t}}=\\mathbf{n}_{\\mathbf{0}} \\cdot B_{0}^{2}(t)+\\left(\\mathbf{n}_{\\mathbf{0}}+\\mathbf{n}_{\\mathbf{1}}-\\delta\\right) / 2 \\cdot B_{1}^{2}(t)+\\mathbf{n}_{\\mathbf{1}} \\cdot B_{2}^{2}(t)$$\r基于伯恩斯坦基控制点的凸包性质，$\\vec{n}_t$受到控制点的限制，控制点为$\\mathbf{n_0}, \\mathbf{n_1}, \\mathbf{(n_0 + n_1 - \\delta)/2}$ ","date":"2023-05-01","objectID":"/ccd/:1:6","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"滤波器 代数非穿透滤波器(DNF) 可以剔除不满足共面条件的碰撞对 对于点面碰撞对，首先计算出三角形 ABC 的法线向量 n，然后计算四个点 PABC 在 n 上的投影点之间的距离，若距离为零，则 PABC 共面，否则不共面。 空间线性投影滤波器 可以剔除部分不满足内部条件的碰撞对 将空间中的碰撞对投影到空间中的某条直线上，根据投影点的位置关系来剔除不可能发生碰撞的碰撞对。 在点面碰撞中，若点的投影点始终在三角形3个顶点的投影点的同一侧，则可剔除；在边边碰撞中，若一条边的两个顶点的投影点始终在另一条边的两个顶点的投影点的同一侧，则可剔除。 基于深度神经网络优化的CCD算法剔除 ","date":"2023-05-01","objectID":"/ccd/:1:7","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"CCD Root finding 三次多项式或多变量求根问题，如果floating-point rounding error无限小，理论上可以精确求解CCD问题 1.基于Inclusion的二分法求根 // 基础的区间算法 // 代码源自CCD-Wrapper namespace Eigen { typedef Matrix\u003cintervalccd::Interval, Dynamic, 1, ColMajor, 3, 1\u003e VectorX3I; //定义一个行数可变，但是不大于3，列数固定为1的列向量 } bool interval_root_finder(const std::function\u003cEigen::VectorX3I(const Eigen::VectorX3I\u0026)\u003e\u0026 f, const std::function\u003cbool(const Eigen::VectorX3I\u0026)\u003e\u0026 constraint_predicate, const Eigen::VectorX3I\u0026 x0, const Eigen::VectorX3d\u0026 tol, Eigen::VectorX3I\u0026 x,const bool check_vf) { std::stack\u003cstd::pair\u003cEigen::VectorX3I, int\u003e\u003e xs; xs.emplace_back(x0, -1); while(!xs.empty()) { // copresond to line 6 x = xs.top().first; int last_split = xs.top().second; xs.pop(); // copresond to line 7 // compute the inclusion function Eigen::VectorX3I y = f(x); if (!zero_in(y)) { continue; } Eigen::VectorX3d widths = width(x); if ((widths.array() \u003c= tol.array()).all()) { if (constraint_predicate(x)) { return true; } continue; } // Bisect the next dimension that is greater than its tolerance int split_i; for (int i = 1; i \u003c= x.size(); i++) { split_i = (last_split + i) % x.size(); if (widths(split_i) \u003e tol(split_i)) { break; } } std::pair\u003cInterval, Interval\u003e halves = bisect(x(split_i)); Eigen::VectorX3I x1 = x; // Push the second half on first so it is examined after the first half if(check_vf){ if(split_i==1){ if(interval_satisfy_constrain(halves.second,x(2))){ x(split_i) = halves.second; xs.emplace(x, split_i); } if(interval_satisfy_constrain(halves.first,x(2))){ x(split_i) = halves.first; xs.emplace(x, split_i); } } if(split_i==2){ if(interval_satisfy_constrain(halves.second,x(1))){ x(split_i) = halves.second; xs.emplace(x, split_i); } if(interval_satisfy_constrain(halves.first,x(1))){ x(split_i) = halves.first; xs.emplace(x, split_i); } } if(split_i==0){ x(split_i) = halves.second; xs.emplace(x, split_i); x(split_i) = halves.first; xs.emplace(x, split_i); } } else{ x(split_i) = halves.second; xs.emplace(x, split_i); x(split_i) = halves.first; xs.emplace(x, split_i); } } } return false } 2.浮点数高精度运算 3.将数值问题转换为射线求交问题 大多数基于单变量公式的算法都会产生false negative 求解器 优点 缺点 interval root-finder (IRF) 没有false negative，有少量的false positive，可以通过调整容差，通过准确性换取效率 区间算法为计算提增加了性能开销，例如计算两个区间的乘积$[a,b] [c,d] = [min(ac,ad,bc,bd),max(ac,ad,bc,bd)]$,需要四次乘法和两次min max操作 univariate interval root-finder (UIRF) 刚体ccd的特殊情况 如果多项式有无穷根，那么该算法将必须将整个域细化到最大允许分辨率，并检查每个区间的有效性，使其正确，但在退化情况下非常慢。这导致比多变量对应的平均运行时间更长。此外，也不可能控制其他两个参数（即u、v）的准确性，从而引入更多的假阳性。 floating-point time-of-impact root finder (FPRF) 这种方法是速度最快的方法之一，是许多仿真代码中的主选。 TightCCD (TCCD) 保守的基于浮点数的实现，速度快，唯一没有false negative的非区间方法 产生了许多不可控制的false positive，这些false positive可能会导致不必要的碰撞检测，从而降低了整体性能。 Root Parity (RP) 根据根的奇偶性来判断是否有碰撞，但是无法区分0根和重根 rational implementation of Root Parity (RRP) 根据根的奇偶性来判断是否有碰撞，但是无法区分0根和重根 BSC MSRF Exact-Root-Parity-CCD 基于RP方法，修复了其部分问题 大多数使用单变量公式的算法都有false negative ","date":"2023-05-01","objectID":"/ccd/:2:0","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["simulation"],"content":"Trajectories ","date":"2023-05-01","objectID":"/ccd/:3:0","tags":["simulation"],"title":"mesh ccd","uri":"/ccd/"},{"categories":["GPU"],"content":"Reduction ","date":"2023-04-17","objectID":"/cub/:0:0","tags":["GPU"],"title":"Reduction","uri":"/cub/"},{"categories":["GPU"],"content":"概念 可以将Reduce操作视为计算$x = x_0\\oplus x_1\\oplus x_2\\oplus …\\oplus x_n$，$\\oplus $作为算子可以表示为乘法，加法，最小值等运算 简易版Reduce //一个基础的Reduce操作,源自NVDIA的教程 __global__ void reduce0(int* g_idata, int* g_odata) { extern __shared__ int sdata[]; unsigned int tid = threadIdx.x; unsigned int i = blockIdx.x*blockDim.x + threadIdx.x; sdata[tid] = g_idata[i]; __syncthreads(); for(unsigned int s=1; s \u003c blockDim.x; s *= 2) { // 此处有warp divergent，并非所有thread都可以进入这个分支中，会造成硬件资源的浪费 // 其次取模操作需要消耗大量计算时间 if(tid % (2*s) == 0) { sdata[tid] += sdata[tid + s]; } __syncthreads(); } if(tid == 0) { g_odata[blockIdx.x] = sdata[0]; } } 修改了if语句以尽量消除warp divergent。但是会产生bank conflict（即不同thread同时访问shared memory下的同一bank） __global__ void reduce2() { extern __shared__ int sdata[]; unsigned int tid = threadIdx.x; unsigned int i = blockIdx.x*blockDim.x + threadIdx.x; sdata[tid] = g_idata[i]; __syncthreads(); for(unsigned int s = 1; s \u003c blockDim.x; s *= 2) { int index = 2 * s * tid; if(index \u003c blockDim.x) { // 会发生bank conflict // 例如在第一次循环中，对于tid为0的线程，会访问sdata的0和1位置 // 对于第16个线程，会访问sdata的32和33的位置 // 0和32位于bank0位置，1和33位于bank1的位置，会产生冲突 // 因此需要改变对数组的读取方式 sdata[index] += sdata[index+s]; } __syncthreads(); } if(tid == 0) { g_odata[blockIdx.x] = sdata[0]; } } 修改对数组的遍历方式以消除bank conflict __global__ void reduce3() { extern __shared__ int sdata[]; unsigned int tid = threadIdx.x; unsigned int i = blockIdx.x*blockDim.x + threadIdx.x; sdata[tid] = g_idata[i]; __syncthreads(); for(unsigned int s = blockDim.x/2; s \u003e 0; s \u003e\u003e= 1) { if(tid \u003c s) { sdata[tid] += sdata[tid + s]; } __syncthreads(); } if(tid == 0) { g_odata[blockIdx.x] = sdata[0]; } } 后续优化 continue… ","date":"2023-04-17","objectID":"/cub/:1:0","tags":["GPU"],"title":"Reduction","uri":"/cub/"},{"categories":["GPU"],"content":"调用CUB库执行Reduce CUB库是一个用于GPU的基本操作库，其中包含了一些基本的操作，如Reduce、Scan等。 CUB的Reduce操作可以分为BlockReduce，DeviceReduce和WarpReduce。 DeviceReduce的主体思路是调用两次Reduce操作，第一次在block上进行Reduce，将结果计入d_out,然后再进行一次Reduce获得值。 #include \u003ccub/cub.cuh\u003e size_t utils::cubTempStorageBytes = 0; void *utils::cubTempStorage = nullptr; static void *cubTempStorage; static size_t cubTempStorageBytes; void utils::allocCubTemp() { printf(\"CUB use mem: %d bytes\\n\", cubTempStorageBytes); checkCudaErrors(cudaMalloc((void **)\u0026cubTempStorage, cubTempStorageBytes * sizeof(int))); } template \u003ctypename T\u003e void utils::maxReduceRegist(int num_items) { T *d_in = nullptr; T *d_out = nullptr; void *storage = nullptr; size_t storage_bytes = 0; cub::DeviceReduce::Max(storage, storage_bytes, d_in, d_out, num_items); if (storage_bytes \u003e cubTempStorageBytes) cubTempStorageBytes = storage_bytes; } template \u003ctypename T\u003e void utils::maxReduce(T *d_in, T *d_out, int num_items) { cub::DeviceReduce::Max(cubTempStorage, cubTempStorageBytes, d_in, d_out, num_items); } ","date":"2023-04-17","objectID":"/cub/:2:0","tags":["GPU"],"title":"Reduction","uri":"/cub/"},{"categories":["GPU"],"content":"CUB库的Reduce操作 template \u003c typename InputIteratorT, typename OutputIteratorT\u003e CUB_RUNTIME_FUNCTION static cudaError_t Max( void *d_temp_storage, ///\u003c [in] Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to \\p temp_storage_bytes and no work is done. size_t \u0026temp_storage_bytes, ///\u003c [in,out] Reference to size in bytes of \\p d_temp_storage allocation InputIteratorT d_in, ///\u003c [in] Pointer to the input sequence of data items OutputIteratorT d_out, ///\u003c [out] Pointer to the output aggregate int num_items, ///\u003c [in] Total number of input items (i.e., length of \\p d_in) cudaStream_t stream = 0, ///\u003c [in] \u003cb\u003e[optional]\u003c/b\u003e CUDA stream to launch kernels within. Default is stream\u003csub\u003e0\u003c/sub\u003e. bool debug_synchronous = false) ///\u003c [in] \u003cb\u003e[optional]\u003c/b\u003e Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is \\p false. { // Signed integer type for global offsets typedef int OffsetT; // The input value type typedef typename std::iterator_traits\u003cInputIteratorT\u003e::value_type InputT; // 此处为入口 return DispatchReduce\u003cInputIteratorT, OutputIteratorT, OffsetT, cub::Max\u003e::Dispatch( d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, cub::Max(), Traits\u003cInputT\u003e::Lowest(), // replace with std::numeric_limits\u003cT\u003e::lowest() when C++11 support is more prevalent stream, debug_synchronous); } CUB_RUNTIME_FUNCTION __forceinline__ static cudaError_t Dispatch( void *d_temp_storage, ///\u003c [in] Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to \\p temp_storage_bytes and no work is done. size_t \u0026temp_storage_bytes, ///\u003c [in,out] Reference to size in bytes of \\p d_temp_storage allocation InputIteratorT d_in, ///\u003c [in] Pointer to the input sequence of data items OutputIteratorT d_out, ///\u003c [out] Pointer to the output aggregate OffsetT num_items, ///\u003c [in] Total number of input items (i.e., length of \\p d_in) ReductionOpT reduction_op, ///\u003c [in] Binary reduction functor OutputT init, ///\u003c [in] The initial value of the reduction cudaStream_t stream, ///\u003c [in] \u003cb\u003e[optional]\u003c/b\u003e CUDA stream to launch kernels within. Default is stream\u003csub\u003e0\u003c/sub\u003e. bool debug_synchronous) ///\u003c [in] \u003cb\u003e[optional]\u003c/b\u003e Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is \\p false. { typedef typename DispatchReduce::MaxPolicy MaxPolicyT; cudaError error = cudaSuccess; do { // Get PTX version int ptx_version = 0; if (CubDebug(error = PtxVersion(ptx_version))) break; // Create dispatch functor DispatchReduce dispatch( d_temp_storage, temp_storage_bytes, d_in, d_out, num_items, reduction_op, init, stream, debug_synchronous, ptx_version); // Dispatch to chained policy if (CubDebug(error = MaxPolicyT::Invoke(ptx_version, dispatch))) break; } while (0); return error; } /// Invocation template \u003ctypename ActivePolicyT\u003e CUB_RUNTIME_FUNCTION __forceinline__ cudaError_t Invoke() { typedef typename ActivePolicyT::SingleTilePolicy SingleTilePolicyT; typedef typename DispatchReduce::MaxPolicy MaxPolicyT; // Force kernel code-generation in all compiler passes if (num_items \u003c= (SingleTilePolicyT::BLOCK_THREADS * SingleTilePolicyT::ITEMS_PER_THREAD)) { // Small, single tile size return InvokeSingleTile\u003cActivePolicyT\u003e( DeviceReduceSingleTileKernel\u003cMaxPolicyT, InputIteratorT, OutputIteratorT, OffsetT, ReductionOpT, OutputT\u003e); } else { // Regular size return InvokePasses\u003cActivePolicyT\u003e( DeviceReduceKernel\u003ctypename DispatchReduce::MaxPolicy, InputIteratorT, OutputT*, OffsetT, ReductionOpT\u003e, DeviceReduceSingleTileKernel\u003cMaxPolicyT, OutputT*, OutputIteratorT, OffsetT, ReductionOpT, OutputT\u003e); } } 此处为CUB库中Reduce操作的核心函数，以InvokePasses为例 //------------------------------------------------------------------------------ // Normal problem size invocation (two-pass) //---------------------------------","date":"2023-04-17","objectID":"/cub/:3:0","tags":["GPU"],"title":"Reduction","uri":"/cub/"}]